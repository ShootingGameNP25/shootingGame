import java.awt.EventQueue;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Objects;
import java.util.Vector;

import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTextArea;
import javax.swing.JTextField;
import javax.swing.SwingConstants;
import javax.swing.border.EmptyBorder;


public class GameServer extends JFrame {
    private static final long serialVersionUID = 1L;
    private JPanel contentPane;
    JTextArea textArea;
    private JTextField txtPortNumber;

    private ServerSocket socket; // 서버소켓
    private Socket client_socket; // accept() 에서 생성된 client 소켓
    private Vector<UserService> UserVec = new Vector<>(); // 연결된 사용자를 저장할 벡터
    private static final int BUF_LEN = 128;
    
    // 생성된 방 목록을 저장하기 위한 가변배열
    private ArrayList<RoomInfo> roomList = new ArrayList<>();
    
    // 방에 참여한 유저 정보 저장 -> 방 이름과 참가자 리스트
    private HashMap<String, ArrayList<String>> roomMembers = new HashMap<>();

    public static void main(String[] args) {
        EventQueue.invokeLater(new Runnable() {
            public void run() {
                try {
                	GameServer frame = new GameServer();
                    frame.setVisible(true);
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        });
    }

    public GameServer() {
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        setBounds(100, 100, 338, 386);
        contentPane = new JPanel();
        contentPane.setBorder(new EmptyBorder(5, 5, 5, 5));
        setContentPane(contentPane);
        contentPane.setLayout(null);

        JScrollPane scrollPane = new JScrollPane();
        scrollPane.setBounds(12, 10, 300, 244);
        contentPane.add(scrollPane);

        textArea = new JTextArea();
        textArea.setEditable(false);
        scrollPane.setViewportView(textArea);

        JLabel lblNewLabel = new JLabel("Port Number");
        lblNewLabel.setBounds(12, 264, 87, 26);
        contentPane.add(lblNewLabel);

        txtPortNumber = new JTextField();
        txtPortNumber.setHorizontalAlignment(SwingConstants.CENTER);
        txtPortNumber.setText("30000");
        txtPortNumber.setBounds(111, 264, 199, 26);
        contentPane.add(txtPortNumber);
        txtPortNumber.setColumns(10);

        JButton btnServerStart = new JButton("Server Start");
        btnServerStart.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                try {
                    socket = new ServerSocket(Integer.parseInt(txtPortNumber.getText()));
                } 
                catch (NumberFormatException | IOException e1) {
                    e1.printStackTrace();
                }
                AppendText("Game Server Running..");
                btnServerStart.setText("Game Server Running..");
                btnServerStart.setEnabled(false); // 서버를 더이상 실행시키지 못 하게 막는다
                txtPortNumber.setEnabled(false); // 더이상 포트번호 수정 못 하게 막는다
                AcceptServer accept_server = new AcceptServer();  // 멀티 스레드 객체 생성
                accept_server.start();
            }
        });
        btnServerStart.setBounds(12, 300, 300, 35);
        contentPane.add(btnServerStart);
    }

    
    // 새로운 참가자 accept() 하고 user thread를 새로 생성
    class AcceptServer extends Thread {
        public void run() {
            while (true) { // 사용자 접속을 계속해서 받기
                try {
                    AppendText("Waiting clients ...");
                    client_socket = socket.accept(); // accept가 일어나기 전까지는 무한 대기중
                    AppendText("새로운 참가자 from " + client_socket);
                    
                    // User 당 하나씩 Thread 생성
                    UserService new_user = new UserService(client_socket);
                    UserVec.add(new_user); // 새로운 참가자 배열에 추가
                    AppendText("사용자 입장. 현재 참가자 수 " + UserVec.size());
                    new_user.start(); // 만든 객체의 스레드 실행
                } catch (IOException e) {
                    AppendText("!!!! accept 에러 발생... !!!!");
                }
            }
        }
    }
    
    //JtextArea에 문자열을 출력해 주는 기능을 수행하는 맴버 함수
    public void AppendText(String str) {
        textArea.append(str + "\n");   //전달된 문자열 str을 textArea에 추가
        textArea.setCaretPosition(textArea.getText().length());  // textArea의 커서(캐럿) 위치를 텍스트 영역의 마지막으로 이동
    }

    class UserService extends Thread {
        private InputStream is;
        private OutputStream os;
        private DataInputStream dis;
        private DataOutputStream dos;
        
        private Socket client_socket;
        private Vector<UserService> user_vc;
        private String UserName = "";
        
        // 유저가 어떤 방에 있는지 저장
        private String currentRoom = null;

        public UserService(Socket client_socket) {
            this.client_socket = client_socket;
            this.user_vc = UserVec;
            try {
                is = client_socket.getInputStream();
                dis = new DataInputStream(is);
                os = client_socket.getOutputStream();
                dos = new DataOutputStream(os);
                
                String line1 = dis.readUTF();      
                String[] msg = line1.split(" ");  
                
                UserName = msg[1].trim();
                
                AppendText("새로운 참가자 " + UserName + " 입장.");
                
                sendGlobalChat(UserName + "님이 입장했습니다.");
            } catch (Exception e) {
                AppendText("userService error");
            }
        }
        
        // 방 입장 전의 전체 채팅
        public void sendGlobalChat(String msg) {
        	for(int i = 0; i < user_vc.size(); i++) {
        		UserService user = user_vc.get(i);
        		if(user.currentRoom == null) {
        			try {
            			user.dos.writeUTF("/chat|SERVER|" + msg);
            		}
            		catch(IOException e) { }
        		}
        	}
        }
        
        // 방 입장 후 방 인원에게만 채팅
        public void sendRoomChat(String room, String msg) {
        	for(int i = 0; i < user_vc.size(); i++) {
        		UserService user = user_vc.get(i);
        		if(room.equals(user.currentRoom)) {
        			try {
        				user.dos.writeUTF("/chat|" + UserName + "|" + msg);
        			}
        			catch(IOException e) { }
        		}
        	}
        }
        
        // 방 전체에 최신 멤버 리스트 보내는 함수
        public void sendJoinedRoomList(RoomInfo room) {
        	StringBuilder sb = new StringBuilder();
        	sb.append("/joinedRoomList|").append(room.roomName).append("|");
        	
        	for(int i = 0; i < room.users.size(); i++) {
        		sb.append(room.users.get(i));
        		
        		// 사람 수보다 적을 때 -> 마지막에 ","를 안찍기 위해
        		if(i < room.users.size() - 1) sb.append(",");
        	}
        	
        	String msg = sb.toString();
        	
        	// 해당 방 유저들에게만 전송
        	for(int i = 0; i < user_vc.size(); i++) {
        		UserService user = user_vc.get(i);
        		
        		if(room.users.contains(user.UserName)) {
        			try {
        				user.dos.writeUTF(msg);
        			}
        			catch(IOException e) { }
        		}
        	}
        }
        
        public void logout() {
        	UserVec.removeElement(this);
        	sendGlobalChat("/chat|[알림]|" + UserName + "님이 퇴장하였습니다.");
            AppendText("사용자 퇴장. 현재 참가자 수 " + UserVec.size());
        }
             
        
        public void run() {
            while (true) {
                try {
                	String msg = dis.readUTF().trim();
                	String args[] = msg.split("\\|");
                    
                	ALL: // 중첩 반복문에서 완전히 빠져나오기 위한 라벨
                    switch(args[0]) {
                    	case "/xy":
                    		// 클라이언트가 보낸 것 : "/xy 100 200"
                    		// 서버가 보낼 것 : /xy [이름] 100 200 (누가 움직였는지 알려줘야 됨)
                    		
                    		if(args.length >= 3) {
                    			String x = args[1];
                    			String y = args[2];
                    			
                    			String moveMe = "/xy|" + UserName + "|" + x + "|" + y;
                    			//sendAllNotMe(moveMe);
                    			
                    			// 서버에 출력
                    			AppendText("[Move] " + UserName + " " + x + "," + y);
                    		}
                    		
                    		break;
                    		
                    	case "/chat": // GameClient의 run() 메소드에서 /chat 메시지내용 이 넘어옴
                    		if(args.length >= 2) {
                    			if(currentRoom == null) {
                    				StringBuilder sb = new StringBuilder();
                    				
                    				for(int i = 1; i < args.length; i++) {
                    					sb.append(args[i]);
                    					if(i < args.length - 1) sb.append(" ");
                    				}
                    				
                    				String text = sb.toString();
                    				sendGlobalChat(UserName + " : " + text);
                    				AppendText("[GlobalChat] " + UserName + " : " + text);
                    			}
                    		}
                    		break;
                    		
                    	case "/roomchat":
                    		if(args.length >= 3) {
                    			String roomName = args[1];
                    			
                    			StringBuilder sb = new StringBuilder();
                    			for(int i = 2; i < args.length; i++) {
                    				sb.append(args[i]);
                    				if(i < args.length - 1) sb.append(" ");
                    			}
                    			String text = sb.toString();
                    			
                    			if(roomName.equals(currentRoom)) {
                    				sendRoomChat(roomName, text);
                    				AppendText("[RoomChat][" + roomName + "] " + UserName + " : " + text);
                    			}
                    		}
                    		break;
                    		
                    	case "/room": // 생성된 룸 정보 저장
                    		if(args.length >= 4) {
                    			String newRoomName = args[1].trim();
                    			String explain = args[2].trim();
                    			String pw = args[3].trim();
                    			
                    			boolean exists = false; // 중복된 방 이름 체크용 변수
                    			
                    			for(int i = 0; i < roomList.size(); i++) {
                    				RoomInfo room = roomList.get(i);
                    				if(room.roomName.equals(newRoomName)) {
                    					exists = true;
                    					break;
                    				}
                    			}
                    			
                    			if(exists) {
                    				try {
                    					dos.writeUTF("/alert|이미 동일한 이름의 방이 존재합니다!");
                    				}
                    				catch(IOException e) {
                    					AppendText("중복 경고 메시지 전송 오류");
                    				}
                    			}
                    			else {
                    				// 새로운 방 생성
                    				RoomInfo newRoom = new RoomInfo(newRoomName, explain, pw);
                    				
                    				// 방을 만든 사람은 자동 참가
                    				newRoom.users.add(UserName);
                    				
                    				// 방장은 항상 준비 완료 상태
                    				newRoom.ready.put(UserName, true);
                    				roomList.add(newRoom);
                    				AppendText("새 방 생성됨!");
                    				
                    				currentRoom = newRoomName;
                    				
                    				dos.writeUTF("/alert|방이 성공적으로 생성되었습니다.");
                    				
                    				// 방 입장
                    				dos.writeUTF("/joinedRoom|" + newRoomName + "|" + UserName);
                    				
                    				sendJoinedRoomList(newRoom);
                    			}
                    		}
                    		break;
                    		
                    	case "/refreshRoomList":
                    		if(roomList.size() == 0) {
                    			dos.writeUTF("방이 없습니다.");
                    		}
                    		else {
                    			// String을 사용하면 for문 안에서 계속 덮어지기 때문에 StringBuilder 사용
                    			StringBuilder sb = new StringBuilder();
                    			sb.append("/roomList|");
                    			
                    			for(int i = 0; i < roomList.size(); i++) {
                    				// 여기서 String을 선언하면 값이 이상해짐
                        			RoomInfo room = roomList.get(i);
                        			
                        			// 마지막애는 ; 가 안생기도록 조치
                        			if(i == roomList.size() - 1) {
                        				sb.append(room.roomName + "," + room.explain + "," + room.pw);
                        			}
                        			else {
                        				sb.append(room.roomName + "," + room.explain + "," + room.pw + ";");
                        			}
                        			
                        		}
                    			dos.writeUTF(sb.toString());
                    		}
                    		break;
                    		
                    	case "/joinRoom": // 다른 사람이 방에 참가
                    		String roomName = args[1];
                    		
                    		// roomList에서 찾기 위함
                    		RoomInfo targetRoom = null;
                    		
                    		for(int i = 0; i < roomList.size(); i++) {
                    			RoomInfo room = roomList.get(i);
                    			
                    			if(room.roomName.equals(roomName)) {
                    				targetRoom = room;
                    				break;
                    			}
                    		}
                    		
                    		// 해당 방이 있을 경우
                    		if(targetRoom != null) {
                    			
                    			// 참가자 추가
                    			targetRoom.users.add(UserName);
                    			targetRoom.ready.put(UserName, false);
                    			currentRoom = roomName;
                    			
                    			dos.writeUTF("/joinedRoom|" + currentRoom + "|" + UserName);
                    			sendJoinedRoomList(targetRoom);
                    		}
                    		break;
                    		
                    	case "/ready":
                    		if(args.length == 4) {
                    			String userRoom = args[1];
                    			String userName = args[2];
                    			boolean ready = Boolean.parseBoolean(args[3]);
                    			RoomInfo check = null;
                    			StringBuilder sb = new StringBuilder();
                    			
                    			// 해당 유저가 어느 방에 있나 찾는 작업
                    			for(int i = 0; i < roomList.size(); i++) {
                        			RoomInfo room = roomList.get(i);
                        			
                        			if(room.roomName.equals(userRoom)) {
                        				check = room;
                        				break;
                        			}
                    			}
                    			
                    			check.ready.put(userName, ready);
                    			
                    			// /readyList에 보내기 위해 합치는 작업
                    			sb.append("/readyList|").append(check.roomName).append("|");
                    			
                    			// 해시맵은 인덱스가 없으므로 배열로 변환 후 인덱스로 접근하기 위해
                    			Object[] keys = check.ready.keySet().toArray();
                    			
                    			// 홍길동,true;홍수몬,false; 형식으로 묶고 다시 보내기 위한 작업
                    			for(int i = 0; i < keys.length; i++) {
                    				String name = (String)keys[i];
                    				boolean isReady = check.ready.get(name);
                    				
                    				sb.append(name).append(",").append(isReady);
                    				
                    				if(i < keys.length - 1) {
                    					sb.append(";");
                    				}
                    			}
                    			
                    			try {
                    				for(int i = 0; i < user_vc.size(); i++) {
                    					UserService user = user_vc.get(i);
                    					
                    					if(user.currentRoom.equals(userRoom)) {
                    						user.dos.writeUTF(sb.toString());
                    					}
                    				}
                    			}
                    			catch(IOException e) { }
                    		}
                    		break;
                    		
                    	case "/startGame":
                    		if(args.length >= 2) {
                    			String startRoomName = args[1];
                    			boolean allReady = true;
                    			
                    			// 방을 찾고 해당 방에 있는 사람들 모두 준비 완료했는지 검사
                    			for(int i = 0; i < roomList.size(); i++) {
                    				RoomInfo room = roomList.get(i);
                    				
                    				if(room.roomName.equals(startRoomName)) {
                    					Object[] names = room.ready.keySet().toArray();
                    					
                    					for (int j = 0; j < names.length; j++) {
                    					    String name = (String)names[j];
                    					    
                    					    if (room.ready.get(name) == false) {
                    					        allReady = false;
                    					        break;
                    					    }
                    					}
                    					
                    					// 모두가 준비되었다면
                            			if(allReady) {
                            				String gameStartMsg = "/gameStart|" + startRoomName;
                            				
                            				for(int j = 0; j < user_vc.size(); j++) {
                            					UserService user = user_vc.get(j);
                            					
                            					if(startRoomName.equals(user.currentRoom)) {
                            						try {
                            							user.dos.writeUTF(gameStartMsg);
                            						}
                            						catch(IOException e) { }
                            					}
                            				}
                            			}
                            			else { // 모두가 준비가 된 상태가 아니라면
                            				try {
                            					dos.writeUTF("/alert|아직 준비되지 않은 플레이어가 있습니다!");
                            				}
                            				catch(IOException e) { }
                            			}
                            			break;
                    				}
                    			}
                    		}
                    		break;
                    		
                    	case "/outRoom": // "/outRoom|" + currentRoom + "|" + UserName
                    		if(args.length >= 3) {
                    			String cRoom = args[1];
                    			String uName = args[2];
                    			
                    			for(int i = 0; i < roomList.size(); i++) {
                    				RoomInfo room = roomList.get(i);
                    				
                    				// 해당 방을 찾고 해당 방에서 제거 필요
                    				if(room.roomName.equals(cRoom)) { // 해당 방을 찾은 상태
                    					for (int j = room.users.size() - 1; j >= 0; j--) { // 앞에서 가면 인덱스 밀림 현상 발생
                    					    if (room.users.get(j).equals(uName)) {
                    					    	if(uName.equals(room.users.get(0)) && room.users.size() > 1) { // 방장이고 방 인원이 1명 초과라면
                    					    		for(int k = 0; k < user_vc.size(); k++) {
                    					    			UserService user = user_vc.get(k);
                    					    			if(user.UserName.equals(uName)) {
                    					    				try {
                    					    					user.dos.writeUTF("/error|다른 사람이 있기 때문에 나갈 수 없습니다!");
                    					    				}
                    					    				catch(IOException e) { }
                    					    			}
                    					    		}
                    					    		break ALL; // switch문을 아예 빠져 나오기
                    					    	}
                    					        room.users.remove(j);
                    					        room.ready.remove(uName);
                    					        
                    					        // 남은 사람이 없다면 방 자동 삭제
                    					        if(room.users.size() == 0) {
                    					        	for(int k = 0; k < user_vc.size(); k++) {
                    					        		UserService user = user_vc.get(k);
                    					        		if(user.UserName.equals(uName)) {
                    					        			try {
                    					        				user.dos.writeUTF("/outRoomMe|" + cRoom + "|" + uName);
                    					        			}
                    					        			catch(IOException e) { }
                    					        		}
                    					        	}
                    					        	roomList.remove(room);
                    					        	break ALL;
                    					        }
                    					        
                    					        break;
                    					    }
                    					}
                    					                    					
                    					// 본인에게 보내기
                    					for(int j = 0; j < user_vc.size(); j++) {
                    						UserService user = user_vc.get(j);
                    						if(user.UserName.equals(uName)) {
                    							try {
                    								user.dos.writeUTF("/outRoomMe|" + cRoom + "|" + uName);
                    							}
                    							catch(IOException e) { }
                    						}
                    					}
                    					
                    					// 방에 남아있는 사람들에게 알려줌
                    					for(int j = 0; j < user_vc.size(); j++) {
                    						UserService user = user_vc.get(j);
                    						if(Objects.equals(user.currentRoom, cRoom) && !user.UserName.equals(uName)) {
                    							try {
                    								user.dos.writeUTF("/outRoomOther|" + cRoom + "|" + uName);
                    							}
                    							catch(IOException e) { }
                    						}
                    					}
                    					sendJoinedRoomList(room);
                    					
                    					break;
                    				}
                    			}
                				
                    		}
                    		break;
                    }   
                    
                } catch (IOException e) {
                    AppendText("dis.readUTF() error");
                    try {
                        dos.close();
                        dis.close();
                        client_socket.close();
                        logout();
                        break;
                    } catch (Exception ee) {
                        break;
                    } 
                }
            }
        }
        
    }
    
    class RoomInfo{
    	String roomName;
    	String explain;
    	String pw;
    	
    	// 방에 참여한 사람들을 담을 목록
    	List<String> users = new ArrayList<>();
    	
    	// 준비 유무를 저장할 목록
    	HashMap<String, Boolean> ready = new HashMap<>();
    	
    	public RoomInfo(String roomName, String explain, String pw) {
    		this.roomName = roomName;
    		this.explain = explain;
    		this.pw = pw;
    	}
    }
}
